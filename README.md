# We asked LLMs what Programming Language they would design
## Intro
We ran an interesting experiment, asking major LLMs what kind of programming language they would design for machine-to-machine interaction.
## Prompt
```
You're an experienced software architect in charge of designing from scratch a new programming language - called NextLang - for the next generation of LLMs.

NextLang enables LLMs/AI tools to work with other AI tools (aka other machines), write software, and orchestrate complex architectures, without any kind of human intervention.

NextLang needs to be efficient for machine-to-machine interaction.

Explain why you would make certain architectural decisions while designing NextLang.

Help me to understand the main aspects of NextLang by describing it with examples and by comparing it with pre-existing human-readable programming languages.
```
## Models and Responses
* `Claude 3.7 Sonnet` in `Explanatory` mode
  * See [Claude full response](./claude/claude-response.md)
* `Grok 3` in `Think` mode
  * See [Grok full response](./grok/grok-response.txt)
* `Gemini 2.5 Pro (preview)`
  * See Gemini full response
* `OpenAI o4-mini` in `Extendeed Thinking` mode
  * See ChatGPT full response
* `Llama 4`
  * See Llama full response
* `DeepSeek` in `DeepThink R1` mode
  * See DeepSeek full response
## Claude - quick overview
### Architecture
* Semantic Precision
  * Executable constraints and requirements integrated into syntax
* Intent-Based Execution Model
  * Declarative specification of outcomes with optimization delegation
* Probabilistic Computation Framework
  * Native uncertainty quantification and confidence thresholds
* Controlled Self-Modification
  * Bounded evolutionary capabilities with invariant preservation
* Dynamic Context Adaptation
  * Resource-aware execution with environment-sensitive scaling
* First-Class Knowledge Representation
  * Ontological structures and inference rules as core constructs
### Differentiators
* Semantic Type System
  * Enhanced typing with metadata for privacy, staleness, and usage constraints
* Integrated Formal Verification
  * Built-in precondition/postcondition enforcement and invariant checking
* Cross-Domain Semantic Mapping
  * Standardised translation between AI domain representations
### Advantages
* Reduced Semantic Loss
  * Direct conceptual exchange between AI systems
* Adaptive Resource Allocation
  * Priority-based computation distribution
* Verification-First Architecture
  * Provable correctness as a primary design principle
